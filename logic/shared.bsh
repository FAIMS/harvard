/*********************************** SHARED ***********************************/
String WEB_REL_NONE = "<i>None</i>";

locusIdentifer = "";

void populateSquare(String ref) {
  String q = "";
  q += " SELECT DISTINCT measure, measure";
  q += " FROM            latestnondeletedaentvalue";
  q += " JOIN            attributekey USING (attributeid)";
  q += " WHERE           attributename = 'Square'";
  q += " AND             measure IS NOT NULL";
  q += " ORDER BY        measure;";

  FetchCallback populate = new FetchCallback() {
    onFetch(result) {
      populateDropDown(ref, result);
    }
  };

  fetchAll(q, populate);
}

void setLocusIdentifierVar(String identiferType, String callback) {
  String uuid = getUuid(identiferType);

  String q = "";
  q += "SELECT uuid, response ";
  q += "FROM latestnondeletedarchentformattedidentifiers ";
  q += "WHERE uuid = '%s' ";
  q  = replaceFirst(q, "%s", uuid);

  cb = new FetchCallback() {
    onFetch(result) {
      if (result != null && result.size() >= 2)
        locusIdentifer = result.get(1);

      execute(callback);
    }
  };

  fetchOne(q, cb);
}

void setFieldToIdentifier(String identiferType, String lotRef) {
  String uuid = getUuid(identiferType);

  if (isNull(uuid)) {
    populateWebViewHtml(lotRef, "&nbsp;");
    return;
  }

  String cb = fun2str(
      "populateWebViewHtml",
      new Object[] {lotRef, locusIdentifer}
  );

  setLocusIdentifierVar(identiferType, cb);
}

void populateLotLabel(String lotRef) {
  identiferType = "Locus";
  setFieldToIdentifier(identiferType, lotRef);
}

boolean isValidTrenchId() {
  String ref = "Site/Site/Trench_ID";
  String trenchId = getFieldValue(ref);
  return trenchId.matches("T\\d+");
}

void clearCursorList(String ref) {
  populateCursorList(ref, "SELECT 0 WHERE 0 LIMIT ? OFFSET ?", 25);
}

List getAttribNamesEndingWith(String ending) {
  List attribNamesEndingWith = new ArrayList();
  for (String ref : DATA_REFS) {
    String attribName = getAttributeName(ref);
    if (attribName.endsWith(ending))
      attribNamesEndingWith.add(attribName);
  }
  return attribNamesEndingWith;
}

String getAttribNamesEndingWithAsString(String ending) {
  List   attribNames       = getAttribNamesEndingWith(ending);
  String attribNamesString = "";

  attribNamesString += "(";
  for (int i = 0; i < attribNames.size() - 1; i++) {
    attribName = attribNames.get(i);
    attribNamesString += "'" + attribName + "', ";
  }
  if (attribNames.size() > 0) {
    int lastIndex = attribNames.size() - 1;
    attribName = attribNames.get(lastIndex);
    attribNamesString += "'" + attribName + "'";
  }
  attribNamesString += ")";

  return attribNamesString;
}

Map MEMOISED_FILTERED_BY_REGEX = new LinkedHashMap();

List filterListByRegex(List unfiltered, String regex, boolean forceUpdate) {
  // Return a copy of the memoised result if possible. It's important to return
  // a copy because if the contents of the list are modified, memoisation will
  // break.
  List key = new ArrayList();
  key.add(unfiltered);
  key.add(regex);

  List memoised = MEMOISED_FILTERED_BY_REGEX.get(key);
  if (memoised != null && !forceUpdate)
    return new ArrayList(memoised);

  // Compute the filtered list
  List filteredList;
  Set  filteredSet = new LinkedHashSet();
  for (element : unfiltered)
    if (element.matches(regex))
      filteredSet.add(element);
  filteredList = new ArrayList(filteredSet);

  // Memoise and return
  MEMOISED_FILTERED_BY_REGEX.put(key, filteredList);
  return new ArrayList(filteredList);
}

List filterListByRegex(List unfiltered, String regex) {
  return filterListByRegex(unfiltered, regex, false);
}

List getRefsMatching(String pattern) {
  Map dict = new HashMap();
  dict.put('/', "\\/");
  dict.put('*', ".*");
  String regex = translate(pattern, dict);

  return filterListByRegex(getRefs(), regex);
}

double parseDouble(String s) {
  try {
    return Double.parseDouble(s);
  } catch (Exception e) {
    return 0.0;
  }
}

double getFieldValueAsDouble(String ref) {
  return parseDouble(getFieldValue(ref));
}

void assert(boolean condition) {
  if (condition)
    return;

  String msg =
    "Test failed: " +
    "Line: " + this.namespace.getInvocationLine() +
    ": "     + this.namespace.getInvocationText() +
    ". "     + this.callstack;

  throw new Exception(msg);
}

ATTRIBS_TRENCH_ID        = getAttribNamesEndingWithAsString("Trench ID");
ATTRIBS_LOCUS_ID         = getAttribNamesEndingWithAsString("Locus ID");
ATTRIBS_SITE_NAME        = getAttribNamesEndingWithAsString("Site Name");
ATTRIBS_YEAR_OF_CAMPAIGN = getAttribNamesEndingWithAsString("Year of Campaign");
