/****************************** PERFORMANCE TEST ******************************/
// As per Adela's request: @christian and @brian - for the preformance test:
// we need minimum 10 site, in each 10 trenches, in each of them 100 loci, 100
// strata, 100 diaries, 100 photologs, 1000 FCNs, with each children having at
// least one picture. Ideally Adela want a separate test where would be all this
// + 2 relationships to each locus, 2 relationships to each stratum too see if
// the relationship do really slow down substantially the module. I will provide
// you with images shortly.
// TODO: Export arch16n entries


import android.database.DatabaseUtils; // TODO: Add to autogen
import java.io.File;
import java.io.FileOutputStream;
import java.nio.channels.Channels;
import java.nio.channels.FileChannel;
import java.nio.channels.ReadableByteChannel;
import java.nio.file.Files;
import java.text.DecimalFormat; // TODO: Add to autogen
import java.util.concurrent.atomic.AtomicInteger;

final long SESS_START_TIME = System.currentTimeMillis();

AtomicInteger PERF_NUM_CBS_TODO   = null;
AtomicInteger PERF_NUM_CBS_DONE   = null;
boolean       PERF_DO_LOG_QUERIES = false;
boolean       PERF_ALLOW_CREATION = false;
String        PERF_TEST_IMG       = "";
              PERF_GET_TYPE_TREE  = null;

// TODO: Add these to autogen and make sure they're used
String dbReplaceFirst(String haystack, String needle, String replacement) {
  String escapedReplacement = DatabaseUtils.sqlEscapeString(replacement);
  return replaceFirst(haystack, needle, escapedReplacement);
}

String dbReplaceFirst(String haystack, String replacement) {
  return dbReplaceFirst(haystack, "%s", replacement);
}

// TODO Add to autogen
void makeLocalID(){
  fetchOne(
      "CREATE TABLE IF NOT EXISTS perflog (" +
      "    id              INTEGER PRIMARY KEY," +
      "    sessStartTime   INTEGER," +
      "    srcLine         TEXT," +
      "    query           TEXT," +
      "    durationMs      INTEGER" +
      "    numAentvalue    INTEGER" +
      "    numArchentity   INTEGER" +
      "    numRelationship INTEGER" +
      "    numAentreln     INTEGER" +
      ")"
  );
  fetchOne(
      "CREATE TABLE IF NOT EXISTS localSettings (" +
      "    key   TEXT PRIMARY KEY," +
      "    value TEXT" +
      ")"
  );
  fetchOne("DROP VIEW IF EXISTS parentchild");
  fetchOne("CREATE VIEW parentchild AS "+
           "           SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename, createdat"+
           "             FROM (SELECT uuid, participatesverb, aenttypename, relationshipid, relntimestamp as createdat"+
           "                     FROM latestnondeletedaentreln "+
           "                     JOIN relationship USING (relationshipid) "+
           "                     JOIN latestnondeletedarchent USING (uuid) "+
           "                     JOIN aenttype USING (aenttypeid)) parent "+
           "             JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "                     FROM latestnondeletedaentreln "+
           "                     JOIN relationship USING (relationshipid) "+
           "                     JOIN latestnondeletedarchent USING (uuid) "+
           "                     JOIN aenttype USING (aenttypeid)) child "+
           "               ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid)");
}
makeLocalID();

int computeCbsNeeded(tree) {
  if (tree == null) return 0;

  int childSum = 0;
  for (child : tree.getChildren())
    childSum += computeCbsNeeded(child);

  boolean isRoot   = isNull(tree.label);
  int     thisNode =        tree.data;

  if (isRoot) return 0        + 1        * childSum;
  else        return thisNode + thisNode * childSum;
}

Tree(String label, Object data) {
  String label    = label;
  Object data     = data;
         parent   = null;
  List   children;

  void addChild(tree) {
    if (super.children == null)
      super.children = new ArrayList();

    tree.setParent(super);
    super.children.add(tree);
  }

  getChild(int i) {
    return super.children.get(i);
  }

  List getChildren() {
    if (super.children == null)
      return new ArrayList();
    return super.children;
  }

  int getNumChildren() {
    if (super.children == null)
      return 0;
    return super.children.size();
  }

  void setParent(tree) {
    super.parent = tree;
  }

  getParent() {
    return super.parent;
  }

  String toString() {
    String s = "\n- " + super.label + " | " + data;
    if (super.children != null)
      for (c : super.children)
        s += c.toString().replace("\n", "\n\t\t");
    return s;
  }

  return this;
}

TimedFetchCallback(String query, FetchCallback cb) {
  String        query      = query;
  FetchCallback cb         = cb;
  bsh.CallStack callstack_ = this.callstack.copy();

  long startTime = System.currentTimeMillis(); // Timer starts here
  long stopTime  = -1;

  void onFetch(Object result) {
    super.stopTimer();
    super.updatePerfLog();

    if (super.cb != null)
      super.cb.onFetch(result);
  }

  void onError(String message) {
    if (super.cb != null)
      super.cb.onError(message);
  }

  void stopTimer() {
    super.stopTime = System.currentTimeMillis();
  }

  double getElapsedMillis() {
    if (stopTime < 0)
      return -Double.MAX_VALUE;
    return super.stopTime - super.startTime;
  }

  void updatePerfLog() {
    DecimalFormat fmt = new DecimalFormat("#.###");

    String sessStartTime = SESS_START_TIME + "";
    String srcLine       = super.callstack_.get(1).getInvocationLine() + "";
    String query         = super.query;
    String durationMs    = fmt.format(super.getElapsedMillis());

    updateQuery += " INSERT INTO perflog (";
    updateQuery += "             sessStartTime,";
    updateQuery += "             srcLine,";
    updateQuery += "             query,";
    updateQuery += "             durationMs,";
    updateQuery += "             numAentvalue,";
    updateQuery += "             numArchentity,";
    updateQuery += "             numRelationship,";
    updateQuery += "             numAentreln)";
    updateQuery += "      SELECT '%s', '%s', '%s', '%s', a, av, r, ar";
    updateQuery += "        FROM";
    updateQuery += "             (SELECT COUNT(*) AS a  FROM archentity  ) a,";
    updateQuery += "             (SELECT COUNT(*) AS av FROM aentvalue   ) av,";
    updateQuery += "             (SELECT COUNT(*) AS r  FROM relationship) r,";
    updateQuery += "             (SELECT COUNT(*) AS ar FROM aentreln    ) ar";

    updateQuery = dbReplaceFirst(updateQuery, sessStartTime);
    updateQuery = dbReplaceFirst(updateQuery, srcLine);
    updateQuery = dbReplaceFirst(updateQuery, query);
    updateQuery = dbReplaceFirst(updateQuery, durationMs);

    fetchOne(updateQuery);
  }

  return this;
}

void timedFetchOne(String q, FetchCallback cb) {
  if (!PERF_DO_LOG_QUERIES) {
    fetchOne(q, cb);
    return;
  }

  tcb = TimedFetchCallback(q, cb);
  fetchOne(q, tcb);
}

void timedFetchOne(String q) {
  fetchOne(q, null);
}

void timedFetchAll(String q, FetchCallback cb) {
  if (!PERF_DO_LOG_QUERIES) {
    fetchAll(q, cb);
    return;
  }

  tcb = TimedFetchCallback(q, cb);
  fetchAll(q, tcb);
}

void timedFetchAll(String q) {
  timedFetchAll(q, null);
}

void timedPopulateCursorList(String ref, String q, int limit) {
  if (PERF_DO_LOG_QUERIES) {
    String boundQ = q;
    boundQ = dbReplaceFirst(boundQ, "?", limit + "");
    boundQ = dbReplaceFirst(boundQ, "?", "0");
    timedFetchAll(boundQ);
  }

  populateCursorList(ref, q, limit);
}

// TODO delete me
void test() {
  String q = "" +
      "SELECT uuid, response "+
      "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
      " WHERE uuid in (SELECT uuid "+
      "                  FROM latestNonDeletedArchEntIdentifiers "+
      "                 WHERE aenttypename = 'Photograph Log'" +
      "               )  "+
      " ORDER BY response ";
  timedFetchAll(q, null);
}
addOnEvent("User/User_List/Module_Guide", "show", "test()");

getTypeTree() {
  // Root
  // 3 - Site
  // 3    - Trench
  // 3      - Locus
  // 3        - Photograph Log
  // 3      - Stratum Feature
  // 3        - Photograph Log
  // 3      - Diary
  // 3      - FCN

  Ph1 = Tree("Photograph Log" , 1);
  Ph2 = Tree("Photograph Log" , 1);
  Loc = Tree("Locus"          , 1);
  Str = Tree("Stratum Feature", 1);
  Dia = Tree("Diary"          , 1);
  fcn = Tree("FCN"            , 1);
  Tre = Tree("Trench"         , 1);
  Sit = Tree("Site"           , 1);
  Roo = Tree(""               , 1);

  Loc.addChild(Ph1);
  Str.addChild(Ph2);

  Tre.addChild(Loc);
  Tre.addChild(Str);
  Tre.addChild(Dia);
  Tre.addChild(fcn);

  Sit.addChild(Tre);

  Roo.addChild(Sit);

  return Roo;
}

void saveEntitiesToPCRel(
    String parentType,
    String childType,
    String parentUuid,
    String childUuid
) {
    String relName = parentType + " - " + childType;
    String pOf     = "Parent Of";
    String cOf     = "Child Of";
    saveEntitiesToHierRel(relName, parentUuid, childUuid, pOf, cOf, "");
}

String randomMenuValue(String ref) {
  List vocabIds = getVocabIdsFromRef(ref);
  int  len      = vocabIds.size();
  if (len <= 0)
    return "";

  Random r   = new Random();
  int    i   = r.nextInt(len);

  return vocabIds.get(i);
}

String getRandomString(int len) {
  char[] chars  = (
      "abcdefghijklmnopqrstuvwxyz" +
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "1234567890"
  ).toCharArray();
  Random random = new Random();

  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < len; i++) {
      char c = chars[random.nextInt(chars.length)];
      sb.append(c);
  }

  return sb.toString();
}

String randomInputValue(String ref) {
  int len = 5;
  randomInputValue(ref, len);
}

String randomInputValue(String ref, int len) {
  if (getType(ref).equals("camera"))
    if (PERF_TEST_IMG.equals(""))
      return "";
    else
      return attachFile(PERF_TEST_IMG, true);
  else
    return getRandomString(len);
}

List getAttribs(String archEntType) {
  List attribs = new ArrayList();
  for (String ref : REF_TO_TYPE.keySet()) {
    String archEntTypeActual = getArchEntType(ref);
    if (!archEntType.equals(archEntTypeActual))
      continue;
    if (!hasData(ref))
      continue;
    if (hasMediaType(ref) && !getType(ref).equals("camera"))
      continue;

    String attribName = getAttributeName(ref);
    String annotation = "";
    String vocab      = "";
    String measure    = "";
    String certainty  = "1.0";

    if (hasMenuType(ref)) vocab   = randomMenuValue (ref);
    else                  measure = randomInputValue(ref);

    EntityAttribute ea = createEntityAttribute(
        attribName,
        annotation,
        vocab,
        measure,
        certainty
    );
    attribs.add(ea);
  }

  return attribs;
}

PerfSaveCallback(tree, String parentUuid) {
  tree              = tree;
  String parentUuid = parentUuid;

  saveRel(uuid) {
    parent            = super.tree.getParent();
    String parentUuid = super.parentUuid;

    if (parent == null || parentUuid == null)
      return;

    String parentType = parent    .label;
    String childType  = super.tree.label;

    saveEntitiesToPCRel(parentType, childType, parentUuid, uuid);
  }

  onSave(uuid, newRecord) {
    int cbsDone = PERF_NUM_CBS_DONE.incrementAndGet();
    int cbsTodo = PERF_NUM_CBS_TODO.get();
    if (cbsTodo == cbsDone)
      displayRecordDigest(cbsDone);

    if (newRecord)
      saveRel(uuid);

    for (subtree : super.tree.getChildren())
      saveArchEnts(subtree, uuid);
  }

  return this;
}

void displayRecordDigest(int numCreated) {
  String q = "";
  q += "   SELECT 'All', count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "    UNION";
  q += "   SELECT aenttypename, count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "     JOIN aenttype USING (aenttypeid)";
  q += " GROUP BY aenttypename";

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      String head = "{perf_digest_1_head}";
      String body = "";
      if (numCreated >= 0)
        body += numCreated + " {perf_digest_1_body_1}";
      body += " {perf_digest_1_body_2}";

      for (List row : result) {
        String type = row.get(0);
        String num  = row.get(1);

        body += "\t- " + type + ": " + num + "\n";
      }

      if (dialog != null)
        dialog.dismiss();
      showWarning(head, body);
    }
  };

  fetchAll(q, cb);
}

void displayRecordDigest() {
  displayRecordDigest(-1);
}

void saveArchEnts(tree, String parentUuid) {
  String archEntName = tree.label;
  int    numEnts     = tree.data;
  cb                 = PerfSaveCallback(tree, parentUuid);

  for (int i = 0; i < numEnts; i++) {
    List attribs = getAttribs(archEntName);
    saveArchEnt(null, archEntName, (List) null, attribs, cb);
  }
}

void createDummyRecords() {
  t = getTypeTree();

  int n = computeCbsNeeded(t);
  PERF_NUM_CBS_TODO = new AtomicInteger(n);
  PERF_NUM_CBS_DONE = new AtomicInteger(0);

  dialog = showBusy("{perf_dummy_busy_head}", n + " {perf_dummy_busy_body}");

  for (child : t)
    saveArchEnts(child, null);
}

PerfImageDownloader() {
  void run() {
    String filStr = "/sdcard/faims/modules/" + getModuleId() +
        "/files/app/test.jpg";
    String urlStr = "http://placeholdit.imgix.net/" +
        "~text?txtsize=100&txt=TEST&w=200&h=200&fm=jpg";

    // Download test image
    new File(filStr).getParentFile().mkdirs();

    long tenMb = 10 * 1024 * 1024;
    URL urlObj = new URL(urlStr);
    ReadableByteChannel in  = Channels.newChannel(urlObj.openStream());
    FileChannel out = new FileOutputStream(filStr).getChannel();
    out.transferFrom(in, 0, tenMb);

    // Set `PERF_TEST_IMG` if the file was created successfully
    File newImg = new File(filStr);
    if (newImg.length() > 0)
      PERF_TEST_IMG = filStr;
  }

  void start() {
    Runnable r = PerfImageDownloader();
    new Thread(r).start();
  }

  return this;
}

void verifyEnableRecordCreation() {
  String q = "";
  q += " SELECT userid, fname, lname, email, password";
  q += "   FROM user";
  q += "  WHERE fname = 'Faims'";
  q += "    AND lname = 'Admin'";

  FetchCallback callback = new FetchCallback() {
    onFetch(result) {
      String userId    = result.get(0);
      String nameFirst = result.get(1);
      String nameLast  = result.get(2);
      String email     = result.get(3);
      String password  = result.get(4);

      User user = new User(userId, nameFirst, nameLast, email, password);
      setUser(user);

      showVerifyUserDialog("enableRecordCreation()");
    }
  };

  fetchOne(q, callback);
}

void enableRecordCreation() {
  PERF_ALLOW_CREATION = true;
  setUpPerfActionBarItems();

  showWarning(
      "Record Creation Enabled!",
      "Record creation is now enabled during this session. Record can be created via the action bar."
  );
}

boolean isInTestTime() {
  SimpleDateFormat fmt      = new SimpleDateFormat("yyyy");
  Date             now      = new Date();
  Date             testTime = fmt.parse("2000");

  return now.before(testTime);
}

// Produce entity number specification
void setUpDummyRecordCreation() {
  // TODO: 
  setUpDummyRecordCreation(PERF_GET_TYPE_TREE, null, "");
}

void setUpDummyRecordCreation(tree, String parentType, String breadCrumbs) {
  String type = tree.label;

  if (parentType == null) breadCrumbs +=         type;
  else                    breadCrumbs += " › " + type;

  showTextAlert(
      breadCrumbs,
      "How many '%s' records should each '%s' contain?",
      "", // TODO: Set tree's node value"
      ""
  );

  for (child : tree.getChildren())
    setUpDummyRecordCreation(child, type, breadCrumbs);
}

void verifyCreateDummyRecords() {
  showWarning(
      "Are You Sure?",
      "Are you sure you want to create dummy records? Tap 'OK' to begin creating entity records, or 'Cancel' to dismiss this message."
      "setUpDummyRecordCreation()",
      ""
  );
}

void setUpPerfActionBarItems() {
  removeActionBarItem("create_dummy_records");
  removeActionBarItem("display_record_digest");
  removeActionBarItem("enable_record_creation");

  ActionButtonCallback createDummyRecords = new ActionButtonCallback() {
      actionOnLabel() {
        "{create_dummy_records}";
      }
      actionOn() {
        verifyCreateDummyRecords();
      }
  };

  ActionButtonCallback displayRecordDigest = new ActionButtonCallback() {
      actionOnLabel() {
        "{display_record_digest}";
      }
      actionOn() {
        displayRecordDigest();
      }
  };

  ActionButtonCallback enableRecordCreation = new ActionButtonCallback() {
      actionOnLabel() {
        "{enable_record_creation}";
      }
      actionOn() {
        verifyEnableRecordCreation();
      }
  };

  // TODO: isDisplayed might not work as expected
  String userMenuTabGroup = getTabGroupRef(userMenuPath);
  if (isInTestTime() && isDisplayed(userMenuTabGroup)) {
    // Careful! The `if` statements are weirdly formatted
    if (PERF_ALLOW_CREATION)
    addActionBarItem("create_dummy_records",   createDummyRecords);
    addActionBarItem("display_record_digest",  displayRecordDigest);
    if (!PERF_ALLOW_CREATION)
    addActionBarItem("enable_record_creation", enableRecordCreation);
  }
}

void setUpPerfTestMode() {
  if (!isInTestTime())
    return;

  PERF_GET_TYPE_TREE = getTypeTree();

  // Enable performance logging
  PERF_DO_LOG_QUERIES = true;

  // Download test image
  PerfImageDownloader().start();

  // Display performance testing notification
  showWarning("{perf_mode_head}", "{perf_mode_body}");
}

setUpPerfTestMode();
addOnEvent(getTabGroupRef(userMenuPath), "show",  "setUpPerfActionBarItems()");
addOnEvent(getTabGroupRef(userMenuPath), "leave", "setUpPerfActionBarItems()");
