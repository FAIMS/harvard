/****************************** PERFORMANCE TEST ******************************/
// As per Adela's request: @christian and @brian - for the preformance test:
// we need minimum 10 site, in each 10 trenches, in each of them 100 loci, 100
// strata, 100 diaries, 100 photologs, 1000 FCNs, with each children having at
// least one picture. Ideally Adela want a separate test where would be all this
// + 2 relationships to each locus, 2 relationships to each stratum too see if
// the relationship do really slow down substantially the module. I will provide
// you with images shortly.
// TODO: Pictures

import java.util.concurrent.atomic.AtomicInteger;
import android.database.DatabaseUtils; // TODO: Add to autogen
import java.text.DecimalFormat; // TODO: Add to autogen

final long SESS_START_TIME = System.currentTimeMillis();

AtomicInteger PERF_NUM_CBS_TODO   = null;
AtomicInteger PERF_NUM_CBS_DONE   = null;
boolean       PERF_DO_LOG_QUERIES = false; // TODO: Set b4 everything else

// TODO: Add these to autogen and make sure they're used
String dbReplaceFirst(String haystack, String needle, String replacement) {
  String escapedReplacement = DatabaseUtils.sqlEscapeString(replacement);
  return replaceFirst(haystack, needle, escapedReplacement);
}

String dbReplaceFirst(String haystack, String replacement) {
  return dbReplaceFirst(haystack, "%s", replacement);
}

// TODO Add to autogen
void makeLocalID(){
  fetchOne(
      "CREATE TABLE IF NOT EXISTS perflog (" +
      "    id            INTEGER PRIMARY KEY," +
      "    sessStartTime INTEGER," +
      "    lineNum       TEXT," +
      "    query         TEXT," +
      "    duration      REAL" +
      ")"
  );
  fetchOne(
      "CREATE TABLE IF NOT EXISTS localSettings (" +
      "    key   TEXT PRIMARY KEY," +
      "    value TEXT" +
      ")"
  );
  fetchOne("DROP VIEW IF EXISTS parentchild");
  fetchOne("CREATE VIEW parentchild AS "+
           "           SELECT parent.uuid as parentuuid, child.uuid as childuuid, parent.participatesverb as parentparticipatesverb, parent.relationshipid, parent.aenttypename as parentaenttypename, child.participatesverb as childparticipatesverb, child.aenttypename as childaenttypename, createdat"+
           "             FROM (SELECT uuid, participatesverb, aenttypename, relationshipid, relntimestamp as createdat"+
           "                     FROM latestnondeletedaentreln "+
           "                     JOIN relationship USING (relationshipid) "+
           "                     JOIN latestnondeletedarchent USING (uuid) "+
           "                     JOIN aenttype USING (aenttypeid)) parent "+
           "             JOIN (SELECT uuid, relationshipid, participatesverb, aenttypename "+
           "                     FROM latestnondeletedaentreln "+
           "                     JOIN relationship USING (relationshipid) "+
           "                     JOIN latestnondeletedarchent USING (uuid) "+
           "                     JOIN aenttype USING (aenttypeid)) child "+
           "               ON (parent.relationshipid = child.relationshipid AND parent.uuid != child.uuid)");
}
makeLocalID();

int computeCbsNeeded(tree) {
  if (tree == null) return 0;

  int childSum = 0;
  for (child : tree.getChildren())
    childSum += computeCbsNeeded(child);

  int thisNode = tree.data;

  return thisNode + thisNode * childSum;
}

Tree(String label, Object data) {
  String label    = label;
  Object data     = data;
         parent   = null;
  List   children;

  void addChild(tree) {
    if (super.children == null)
      super.children = new ArrayList();

    tree.setParent(super);
    super.children.add(tree);
  }

  getChild(int i) {
    return super.children.get(i);
  }

  List getChildren() {
    if (super.children == null)
      return new ArrayList();
    return super.children;
  }

  int getNumChildren() {
    if (super.children == null)
      return 0;
    return super.children.size();
  }

  void setParent(tree) {
    super.parent = tree;
  }

  getParent() {
    return super.parent;
  }

  String toString() {
    String s = "\n- " + super.label + " | " + data;
    if (super.children != null)
      for (c : super.children)
        s += c.toString().replace("\n", "\n\t\t");
    return s;
  }

  return this;
}

TimedFetchCallback(String query, FetchCallback cb) {
  String        query      = query;
  FetchCallback cb         = cb;
  bsh.CallStack callstack_ = this.callstack.copy();

  long startTime = System.currentTimeMillis(); // Timer starts here
  long stopTime  = -1;

  void onFetch(Object result) {
    super.stopTimer();
    super.updatePerfLog();

    if (super.cb != null)
      super.cb.onFetch(result);
  }

  void onError(String message) {
    if (super.cb != null)
      super.cb.onError(message);
  }

  void stopTimer() {
    super.stopTime = System.currentTimeMillis();
  }

  double getElapsedSecs() {
    if (stopTime < 0)
      return -Double.MAX_VALUE;
    return (super.stopTime - super.startTime) / 1000.0;
  }

  void updatePerfLog() {
    DecimalFormat fmt = new DecimalFormat("#.###");

    String sessStartTime = SESS_START_TIME + "";
    String lineNum       = super.callstack_.get(1).getInvocationLine() + "";
    String query         = super.query;
    String duration      = fmt.format(super.getElapsedSecs());

    String updateQuery = "";
    updateQuery += " INSERT INTO perflog (";
    updateQuery += "     sessStartTime, lineNum, query, duration";
    updateQuery += " ) VALUES (%s, %s, %s, %s)";

    updateQuery = dbReplaceFirst(updateQuery, sessStartTime);
    updateQuery = dbReplaceFirst(updateQuery, lineNum);
    updateQuery = dbReplaceFirst(updateQuery, query);
    updateQuery = dbReplaceFirst(updateQuery, duration);

    fetchOne(updateQuery);
  }

  return this;
}

void timedFetchOne(String q, FetchCallback cb) {
  if (!PERF_DO_LOG_QUERIES) {
    fetchOne(q, cb);
    return;
  }

  tcb = TimedFetchCallback(q, cb);
  fetchOne(q, tcb);
}

void timedFetchOne(String q) {
  fetchOne(q, null);
}

void timedFetchAll(String q, FetchCallback cb) {
  if (!PERF_DO_LOG_QUERIES) {
    fetchAll(q, cb);
    return;
  }

  tcb = TimedFetchCallback(q, cb);
  fetchAll(q, tcb);
}

void timedFetchAll(String q) {
  timedFetchAll(q, null);
}

void timedPopulateCursorList(String ref, String q, int limit) {
  if (PERF_DO_LOG_QUERIES) {
    String boundQ = q;
    boundQ = dbReplaceFirst(boundQ, "?", limit + "");
    boundQ = dbReplaceFirst(boundQ, "?", "0");
    timedFetchAll(boundQ);
  }

  populateCursorList(ref, q, limit);
}

// TODO delete me
void test() {
  String q = "" +
      "SELECT uuid, response "+
      "  FROM latestNonDeletedArchEntFormattedIdentifiers  "+
      " WHERE uuid in (SELECT uuid "+
      "                  FROM latestNonDeletedArchEntIdentifiers "+
      "                 WHERE aenttypename = 'Photograph Log'" +
      "               )  "+
      " ORDER BY response ";
  timedFetchAll(q, null);
}
addOnEvent("User/User_List/Module_Guide", "show", "test()");

getRecordTypeTree() {
  // Site
  //  - Trench
  //    - Locus
  //      - Photograph Log
  //    - Stratum Feature
  //      - Photograph Log
  //    - Diary
  //    - FCN

  Ph1 = Tree("Photograph Log" , 2);
  Ph2 = Tree("Photograph Log" , 2);
  Loc = Tree("Locus"          , 2);
  Str = Tree("Stratum Feature", 2);
  Dia = Tree("Diary"          , 2);
  fcn = Tree("FCN"            , 2);
  Tre = Tree("Trench"         , 2);
  Sit = Tree("Site"           , 2);

  Loc.addChild(Ph1);
  Str.addChild(Ph2);

  Tre.addChild(Loc);
  Tre.addChild(Str);
  Tre.addChild(Dia);
  Tre.addChild(fcn);

  Sit.addChild(Tre);

  return Sit;
}

void saveEntitiesToPCRel(
    String parentType,
    String childType,
    String parentUuid,
    String childUuid
) {
    String relName = parentType + " - " + childType;
    String pOf     = "Parent Of";
    String cOf     = "Child Of";
    saveEntitiesToHierRel(relName, parentUuid, childUuid, pOf, cOf, "");
}

String randomMenuValue(String ref) {
  List vocabIds = getVocabIdsFromRef(ref);
  int  len      = vocabIds.size();
  if (len <= 0)
    return "";

  Random r   = new Random();
  int    i   = r.nextInt(len);

  return vocabIds.get(i);
}

String getRandomString(int len) {
  char[] chars  = (
      "abcdefghijklmnopqrstuvwxyz" +
      "ABCDEFGHIJKLMNOPQRSTUVWXYZ" +
      "1234567890"
  ).toCharArray();
  Random random = new Random();

  StringBuilder sb = new StringBuilder();
  for (int i = 0; i < len; i++) {
      char c = chars[random.nextInt(chars.length)];
      sb.append(c);
  }

  return sb.toString();
}

String randomInputValue(String ref) {
  int len = 5;
  randomInputValue(ref, len);
}

String randomInputValue(String ref, int len) {
  return getRandomString(len);
}

List getAttribs(String archEntType) {
  List attribs = new ArrayList();
  for (String ref : REF_TO_TYPE.keySet()) {
    String archEntTypeActual = getArchEntType(ref);
    if (!archEntType.equals(archEntTypeActual))
      continue;
    if (!hasData(ref))
      continue;
    if (hasMediaType(ref))
      continue;

    String attribName = getAttributeName(ref);
    String annotation = "";
    String vocab      = "";
    String measure    = "";
    String certainty  = "1.0";

    if (hasMenuType(ref)) vocab   = randomMenuValue (ref);
    else                  measure = randomInputValue(ref);

    EntityAttribute ea = createEntityAttribute(
        attribName,
        annotation,
        vocab,
        measure,
        certainty
    );
    attribs.add(ea);
  }

  return attribs;
}

PerfSaveCallback(tree, String parentUuid) {
  tree              = tree;
  String parentUuid = parentUuid;

  saveRel(uuid) {
    parent            = super.tree.getParent();
    String parentUuid = super.parentUuid;

    if (parent == null || parentUuid == null)
      return;

    String parentType = parent    .label;
    String childType  = super.tree.label;

    saveEntitiesToPCRel(parentType, childType, parentUuid, uuid);
  }

  onSave(uuid, newRecord) {
    int cbsDone = PERF_NUM_CBS_DONE.incrementAndGet();
    int cbsTodo = PERF_NUM_CBS_TODO.get();
    if (cbsTodo == cbsDone)
      displayRecordDigest(cbsDone);

    if (newRecord)
      saveRel(uuid);

    for (subtree : super.tree.getChildren())
      saveArchEnts(subtree, uuid);
  }

  return this;
}

void displayRecordDigest(int numCreated) {
  String q = "";
  q += "   SELECT 'All', count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "    UNION";
  q += "   SELECT aenttypename, count(*)";
  q += "     FROM latestnondeletedarchent";
  q += "     JOIN aenttype USING (aenttypeid)";
  q += " GROUP BY aenttypename";

  FetchCallback cb = new FetchCallback() {
    onFetch(result) {
      String head = "{perf_digest_1_head}";
      String body = "";
      if (numCreated != -1)
        body += numCreated + " {perf_digest_1_body_1}";
      body += " {perf_digest_1_body_2}";

      for (List row : result) {
        String type = row.get(0);
        String num  = row.get(1);

        body += "\t- " + type + ": " + num + "\n";
      }

      if (dialog != null)
        dialog.dismiss();
      showWarning(head, body);
    }
  };

  fetchAll(q, cb);
}

void displayRecordDigest() {
  displayRecordDigest(-1);
}

void saveArchEnts(tree, String parentUuid) {
  String archEntName = tree.label;
  int    numEnts     = tree.data;
  cb                 = PerfSaveCallback(tree, parentUuid);

  for (int i = 0; i < numEnts; i++) {
    List attribs = getAttribs(archEntName);
    saveArchEnt(null, archEntName, (List) null, attribs, cb);
  }
}

void makeDummyRecords() {
  t = getRecordTypeTree();

  int n = computeCbsNeeded(t);
  PERF_NUM_CBS_TODO = new AtomicInteger(n);
  PERF_NUM_CBS_DONE = new AtomicInteger(0);

  dialog = showBusy("{perf_dummy_busy_head} ", n + "{perf_dummy_busy_body}");

  saveArchEnts(t, null);
}

void promptPerformanceMode() {
  SimpleDateFormat fmt      = new SimpleDateFormat("yyyy");
  Date             now      = new Date();
  Date             testTime = fmt.parse("2015");

  boolean isInTestTime = now.before(testTime);
  if (isInTestTime) {
    PERF_DO_LOG_QUERIES = true;

    String head;
    String body;
    String cbOk;
    String cbBad;

    head = "{perf_dummy_head}";
    body =  "{perf_dummy_body_1} " + computeCbsNeeded(getRecordTypeTree()) +
           " {perf_dummy_body_2}";
    String cbOk  = "makeDummyRecords()";
    String cbBad = "";
    showAlert(head, body, cbOk, cbBad);

    head = "{perf_digest_2_head}";
    body = "{perf_digest_2_body}";
    String cbOk  = "displayRecordDigest()";
    String cbBad = "";
    showAlert(head, body, cbOk, cbBad);

    head = "{perf_mode_head}";
    body = "{perf_mode_body}";
    showWarning(head, body);
  }
}

promptPerformanceMode();
